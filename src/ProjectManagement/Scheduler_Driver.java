package ProjectManagement;///////can it be importedimport PriorityQueue.MaxHeap;import Trie.Trie;import RedBlack.RBTree;import java.io.*;import java.net.URL;import java.util.ArrayList;public class Scheduler_Driver extends Thread implements SchedulerInterface{	private static ArrayList<Job> JOBS=new ArrayList<Job>();	private static ArrayList<User> USERS=new ArrayList<User>();	private static MaxHeap<Job> alljobs=new MaxHeap<Job>();//current jobs	//private static MaxHeap<Job> unfinishedjobs=new MaxHeap<Job>();//not enough budget	private static MaxHeap<Project> PROJECTS=new MaxHeap<Project>();//not enough budget	private static Trie<Project> allprojects=new Trie<Project>();	private static Trie<User> allusers=new Trie<User>();	private static RBTree<String,Job> jobs=new RBTree<String,Job>();	private static RBTree<String,Job> jobs2=new RBTree<String,Job>();	private static RBTree<String,Job> jobs2completed=new RBTree<String,Job>();	private static RBTree<String,Job> jobs3=new RBTree<String,Job>();	private static RBTree<String,Job> jobs3completed=new RBTree<String,Job>();	private static RBTree<String,MaxHeap<Job>> waitjobs=new RBTree<String,MaxHeap<Job>>();	private static ArrayList<Job> completedjobs=new ArrayList<Job>();	private static int totaljobs=0;	private static int globaltime=0;	private static int v=0;	public static void main(String[] args) throws IOException {//		Scheduler_Driver scheduler_driver = new Scheduler_Driver();		File file;		if (args.length == 0) {			URL url = Scheduler_Driver.class.getResource("INP");			file = new File(url.getPath());		} else {			file = new File(args[0]);		}		scheduler_driver.execute(file);	}	public void execute(File commandFile) throws IOException {		BufferedReader br = null;		try {			br = new BufferedReader(new FileReader(commandFile));			String st;			while ((st = br.readLine()) != null) {				String[] cmd = st.split(" ");				if (cmd.length == 0) {					System.err.println("Error parsing: " + st);					return;				}				String project_name, user_name;				Integer start_time, end_time;				long qstart_time, qend_time;				switch (cmd[0]) {					case "PROJECT":						handle_project(cmd);						break;					case "JOB":						handle_job(cmd);						break;					case "USER":						handle_user(cmd[1]);						break;					case "QUERY":						handle_query(cmd[1]);						break;					case "": // HANDLE EMPTY LINE						handle_empty_line();						break;					case "ADD":						handle_add(cmd);						break;					//--------- New Queries					case "NEW_PROJECT":					case "NEW_USER":					case "NEW_PROJECTUSER":					case "NEW_PRIORITY":						timed_report(cmd);						break;					case "NEW_TOP":						qstart_time = System.nanoTime();						timed_top_consumer(Integer.parseInt(cmd[1]));						qend_time = System.nanoTime();						System.out.println("Time elapsed (ns): " + (qend_time - qstart_time));						break;					case "NEW_FLUSH":						qstart_time = System.nanoTime();						timed_flush( Integer.parseInt(cmd[1]));						qend_time = System.nanoTime();						System.out.println("Time elapsed (ns): " + (qend_time - qstart_time));						break;					default:						System.err.println("Unknown command: " + cmd[0]);				}			}			run_to_completion();			print_stats();		} catch (FileNotFoundException e) {			System.err.println("Input file Not found. " + commandFile.getAbsolutePath());		} catch (NullPointerException ne) {			ne.printStackTrace();		}	}	@Override	public ArrayList<JobReport_> timed_report(String[] cmd) {		//long qstart_time, qend_time;		ArrayList<JobReport_> res = null;		switch (cmd[0]) {			case "NEW_PROJECT":				//qstart_time = System.nanoTime();				res = handle_new_project(cmd);				//qend_time = System.nanoTime();				//System.out.println("Time elapsed (ns): " + (qend_time - qstart_time));				break;			case "NEW_USER":				//qstart_time = System.nanoTime();				res = handle_new_user(cmd);				//qend_time = System.nanoTime();				//System.out.println("Time elapsed (ns): " + (qend_time - qstart_time));				break;			case "NEW_PROJECTUSER":				//qstart_time = System.nanoTime();				res = handle_new_projectuser(cmd);				//qend_time = System.nanoTime();				//System.out.println("Time elapsed (ns): " + (qend_time - qstart_time));				break;			case "NEW_PRIORITY":				//qstart_time = System.nanoTime();				res = handle_new_priority(cmd[1]);				//qend_time = System.nanoTime();				//System.out.println("Time elapsed (ns): " + (qend_time - qstart_time));				break;		}		return res;	}/*	public ArrayList<UserReport_> handle_new_top(String top)	{		return timed_top_consumer(Integer.parseInt(top));	}*/	@Override	public ArrayList<UserReport_> timed_top_consumer(int top)	{		//System.out.println("TOP");		int l=USERS.size();		MaxHeap<User> yss=new MaxHeap<User>();		for(int i=0;i<l;i++)		{			yss.insert(USERS.get(i));		}		ArrayList<UserReport_> bb=new ArrayList<>();		if(top>l) top=l;		for(int i=0;i<top;i++)		{			User u=yss.extractMax();			//System.out.println(u.name()+ " "+u.consumed());			bb.add(u);		}		return bb;	}/*	@Override	public void timed_flush(int waittime)	{		//System.out.println("FLUSH");		ArrayList<Job> temp=new ArrayList<>();		//MaxHeap<Job> temp=new MaxHeap<Job>();		//ArrayList<Job> tt=new ArrayList<>();		//MaxHeap<Job> tt=new MaxHeap<Job>();		int tglobal=globaltime;		while(alljobs.length()>0)		{			Job j=alljobs.extractMax();			if(tglobal-j.arrival_time()>=waittime && j.getRunTime()<=j.budget())			{					//j.setPriority(9999);					//execute_a_job();				j.getProject().setBudget(j.budget()-j.getRunTime());				j.setStatus();				globaltime+=j.getRunTime();				j.setEndTime(globaltime);				completedjobs.add(j);				j.getUser().consumed(j.getRunTime());				j.getUser().setLatest(globaltime);				jobs2completed.insert(j.projectName(),j);				jobs3completed.insert(j.userName(),j);				//System.out.println(j.toString());				//tt.add(j);				//System.out.println(j.toString()+ "    ////////////");			}			else			{				temp.add(j);			}		}		//System.out.println("Flush query\nTotal pushed: "+tt.length());		*//*int l=tt.size();		for(int i=0;i<l;i++)		{			Job j=tt.get(i);			System.out.println(j.toString());			//alljobs.insert(j);		}*//*		int ll=temp.size();		for(int i=0;i<ll;i++)		{			Job j=temp.get(i);			//System.out.println(j.toString());			alljobs.insert(j);		}	}*/	@Override	public void timed_flush(int waittime)	{		//System.out.println("FLUSH");		ArrayList<Job> list=(ArrayList)alljobs.list();		int tglobal=globaltime;		int l=alljobs.length();		for(int i=0;i<l;i++)		{			Job j=list.get(i);			if(tglobal-j.arrival_time()>=waittime)// && j.getRunTime()<=j.budget())			{				j.setPriority(j.getPriority()+10000);				int k=i;				while(k>0)				{					if(list.get(k).compareTo(list.get((k-1)/2)) > 0)					{						Job jtemp=list.get((k-1)/2);						list.set((k-1)/2,list.get(k));						list.set(k,jtemp);						k=(k-1)/2;					}					else break;				}			}		}		while(alljobs.length()>0)		{		    Job j=list.get(0);			if(j.getPriority()<10000)			    break;            j=alljobs.extractMax();			j.setPriority(j.getPriority()-10000);			if(tglobal-j.arrival_time()>=waittime && j.getRunTime()<=j.budget())			{				//j.setPriority(9999);				//execute_a_job();				j.getProject().setBudget(j.budget()-j.getRunTime());				j.setStatus();				globaltime+=j.getRunTime();				j.setEndTime(globaltime);				completedjobs.add(j);				j.getUser().consumed(j.getRunTime());				j.getUser().setLatest(globaltime);				jobs2completed.insert(j.projectName(),j);				jobs3completed.insert(j.userName(),j);				//System.out.println(j.toString());				//tt.add(j);				//System.out.println(j.toString()+ "    ////////////");			}			else				alljobs.insert(j);		}	}	private ArrayList<JobReport_> handle_new_priority(String s)	{		//System.out.println("Priority query");		int l=JOBS.size(),k=Integer.parseInt(s);		ArrayList<JobReport_> bb=new ArrayList<>();		for(int i=0;i<l;i++)		{			Job j=JOBS.get(i);			if(j.getStatus().equals("REQUESTED") && j.getPriority()>=k)			{				//System.out.println(j.jobName()+ "    //////");				bb.add(j);			}		}		return bb;	}	private ArrayList<JobReport_> handle_new_projectuser(String[] cmd) {		//System.out.println("Project User query");		int a = Integer.parseInt(cmd[3]), b = Integer.parseInt(cmd[4]);		ArrayList<Job> t1 = (ArrayList) jobs2completed.search(cmd[1]).getValues();		ArrayList<Job> t2 = (ArrayList) jobs2.search(cmd[1]).getValues();		ArrayList<JobReport_> bb = new ArrayList<>();		if (t1 != null)		{			int l1 = t1.size();			for (int i = 0; i < l1; i++) {				Job j = t1.get(i);				if (j.arrival_time() > b)					break;				if (j.userName().equals(cmd[2]) && j.arrival_time() <= b && j.arrival_time() >= a) {					//System.out.println(j.jobName()+ "    //////");					bb.add(j);				}			}		}		int l2=t2.size();		for(int i=0;i<l2;i++)		{			Job j=t2.get(i);			if(j.arrival_time()>b)				break;			if(j.userName().equals(cmd[2]) && j.getStatus().equals("REQUESTED"))				if(j.arrival_time()<=b && j.arrival_time()>=a)				{					//System.out.println(j.jobName()+ "    //////");					bb.add(j);				}		}		return bb;	}	private ArrayList<JobReport_> handle_new_user(String[] cmd)	{		//System.out.println("User query");		int a=Integer.parseInt(cmd[2]),b=Integer.parseInt(cmd[3]);		//ArrayList<Job> t1=(ArrayList)jobs3completed.search(cmd[1]).getValues();		ArrayList<Job> t2=(ArrayList)jobs3.search(cmd[1]).getValues();		ArrayList<JobReport_> bb= new ArrayList<>();		int l2=t2.size();		for(int i=0;i<l2;i++)		{			Job j=t2.get(i);				if(j.arrival_time()>b)					break;				if(j.arrival_time()>=a)				{					//System.out.println(j.jobName()+ "    //////");					bb.add(j);				}		}		return bb;	}	private ArrayList<JobReport_> handle_new_project(String[] cmd)	{		//System.out.println("Project query");		int a=Integer.parseInt(cmd[2]),b=Integer.parseInt(cmd[3]);		//ArrayList<Job> t1=(ArrayList)jobs2completed.search(cmd[1]).getValues();		ArrayList<Job> t2=(ArrayList)jobs2.search(cmd[1]).getValues();		ArrayList<JobReport_> bb= new ArrayList<>();		int l2=t2.size();		for(int i=0;i<l2;i++)		{			Job j=t2.get(i);				if(j.arrival_time()>b)					break;				if(j.arrival_time()>=a)				{					//System.out.println(j.jobName()+ "    //////");					bb.add(j);				}		}		return bb;	}	public void execute_a_job()	{		if(alljobs.length()>0)		{			Job j=alljobs.extractMax();			//System.out.println("\tExecuting: "+j.jobName()+" from: "+j.projectName());			Project p=j.getProject();			//j.setQueue(false);			if(j.getRunTime()<=p.getBudget())			{				p.setBudget(p.getBudget()-j.getRunTime());				//System.out.println("\tProject: "+p.projectName()+" budget remaining: "+p.getBudget());				j.setStatus();				globaltime+=j.getRunTime();				j.setEndTime(globaltime);				completedjobs.add(j);				j.getUser().consumed(j.getRunTime());				j.getUser().setLatest(globaltime);				jobs2completed.insert(j.projectName(),j);				jobs3completed.insert(j.userName(),j);				//break;			}			else				waitjobs.search(p.projectName()).getValue().insert(j);			//unfinishedjobs.insert(j);			//System.out.println("\tUn-sufficient budget.");		}		//System.out.println("System execution completed");	}    @Override    public void run()	{        // till there are JOBS        schedule();    }    @Override    public void run_to_completion()    {    	while(true)    	{    		if(alljobs.length()<=0)        		break;        	System.out.println("Running code");        	System.out.println("\tRemaining jobs: "+alljobs.length());        	run();        	System.out.println("System execution completed");    	}    }    @Override    public void handle_project(String[] cmd)    {    	System.out.println("Creating project");    	Project p=new Project(cmd[1],Integer.parseInt(cmd[2]),Integer.parseInt(cmd[3]));    	allprojects.insert(p.projectName(),p);    	PROJECTS.insert(p);    	waitjobs.insert(p.projectName(),new MaxHeap<Job>());    }    @Override    public void handle_job(String[] cmd)    {    	System.out.println("Creating job");    	Job j=new Job(cmd[1],cmd[2],cmd[3],cmd[4]);		if(allprojects.search(cmd[2])==null)		{			System.out.println("No such project exists. "+cmd[2]);			return;		}    	if(allusers.search(cmd[3])==null)    	{    		System.out.println("No such user exists: "+cmd[3]);    		return;    	}    	User u=allusers.search(cmd[3]).getValue();    	Project p=allprojects.search(cmd[2]).getValue();    	j.setProject(p);    	j.setUser(u);    	j.setArrivalTime(globaltime);    	j.setCreatetime(v++);    	//currently added to priority queue    	alljobs.insert(j);    	//contains all jobs		JOBS.add(j);    	jobs.insert(cmd[1],j);//Job as key    	jobs2.insert(j.projectName(),j);//User as key    	jobs3.insert(j.userName(),j);//Project as key    	totaljobs++;    }    @Override    public void handle_user(String name)    {    	System.out.println("Creating user");    	User u=new User(name);    	allusers.insert(name,u);    	USERS.add(u);    }    @Override    public void handle_query(String key)    {    	System.out.print("Querying\n"+key+": ");    	if(jobs.search(key).getValues()==null)    	{    		System.out.println("NO SUCH JOB");    		return;    	}    	Job j=jobs.search(key).getValue();    	if(j.getStatus().equals("COMPLETED"))    		System.out.println("COMPLETED");    	else    		System.out.println("NOT FINISHED");    }    @Override    public void handle_empty_line()    {    	if(alljobs.length()<=0)    		return;    	System.out.println("Running code\n\tRemaining jobs: "+alljobs.length());    	schedule();    	System.out.println("Execution cycle completed");    }    @Override    public void handle_add(String[] cmd)    {    	System.out.println("ADDING Budget");    	if(allprojects.search(cmd[1])==null)    	{    		System.out.println("No such project exists. "+cmd[1]);    		return;    	}    	Project p=allprojects.search(cmd[1]).getValue();    	p.setBudget(p.getBudget() + Integer.parseInt(cmd[2]));    	//check if already present in priorityqueue		MaxHeap<Job> temp=waitjobs.search(p.projectName()).getValue();    	while(temp.length()>0)    	{    		Job j=temp.extractMax();    		alljobs.insert(j);    	}    }    @Override    public void print_stats()    {    	int l=completedjobs.size();    	System.out.print("--------------STATS---------------\nTotal jobs done: ");    	System.out.println(l);    	for(int i=0;i<l;i++)    		System.out.println(completedjobs.get(i).toString());    	System.out.println("------------------------\nUnfinished jobs: ");    	while(PROJECTS.length()>0)		{			Project p=PROJECTS.extractMax();			MaxHeap<Job> tt=waitjobs.search(p.projectName()).getValue();			while(tt.length()>0)			{				System.out.println(tt.extractMax().toString());			}		}    	System.out.println("Total unfinished jobs: "+(totaljobs-l));    	System.out.println("--------------STATS DONE---------------");    }    @Override    public void schedule()    {    	while(alljobs.length()>0)    	{    		Job j=alljobs.extractMax();    		System.out.println("\tExecuting: "+j.jobName()+" from: "+j.projectName());    		Project p=j.getProject();    		//j.setQueue(false);    		if(j.getRunTime()<=p.getBudget())    		{    			p.setBudget(p.getBudget()-j.getRunTime());    			System.out.println("\tProject: "+p.projectName()+" budget remaining: "+p.getBudget());    			j.setStatus();    			globaltime+=j.getRunTime();    			j.setEndTime(globaltime);    			completedjobs.add(j);    			j.getUser().consumed(j.getRunTime());    			j.getUser().setLatest(globaltime);    			jobs2completed.insert(j.projectName(),j);    			jobs3completed.insert(j.userName(),j);    			break;    		}    		waitjobs.search(p.projectName()).getValue().insert(j);    		//unfinishedjobs.insert(j);    		System.out.println("\tUn-sufficient budget.");    	}    }	public void timed_handle_user(String name)	{		//System.out.println("Creating user");		User u=new User(name);		allusers.insert(name,u);		USERS.add(u);	}	public void timed_handle_job(String[] cmd)	{		//System.out.println("Creating job");		Job j=new Job(cmd[1],cmd[2],cmd[3],cmd[4]);		if(allprojects.search(cmd[2])==null)		{			//System.out.println("No such project exists. "+cmd[2]);			return;		}		if(allusers.search(cmd[3])==null)		{			//System.out.println("No such user exists: "+cmd[3]);			return;		}		User u=allusers.search(cmd[3]).getValue();		Project p=allprojects.search(cmd[2]).getValue();		j.setProject(p);		j.setUser(u);		j.setArrivalTime(globaltime);		j.setCreatetime(v++);		//currently added to priority queue		alljobs.insert(j);		//contains all jobs		JOBS.add(j);		jobs.insert(cmd[1],j);//Job as key		jobs2.insert(j.projectName(),j);//User as key		jobs3.insert(j.userName(),j);//Project as key		totaljobs++;	}	public void timed_handle_project(String[] cmd)	{		//System.out.println("Creating project");		Project p=new Project(cmd[1],Integer.parseInt(cmd[2]),Integer.parseInt(cmd[3]));		allprojects.insert(p.projectName(),p);		PROJECTS.insert(p);		waitjobs.insert(p.projectName(),new MaxHeap<Job>());	}	public void timed_run_to_completion()	{		while(true)		{			if(alljobs.length()<=0)				break;			//System.out.println("Running code");			//System.out.println("\tRemaining jobs: "+alljobs.length());			//run();			while(alljobs.length()>0)			{				Job j=alljobs.extractMax();				//System.out.println("\tExecuting: "+j.jobName()+" from: "+j.projectName());				Project p=j.getProject();				//j.setQueue(false);				if(j.getRunTime()<=p.getBudget())				{					p.setBudget(p.getBudget()-j.getRunTime());					//System.out.println("\tProject: "+p.projectName()+" budget remaining: "+p.getBudget());					j.setStatus();					globaltime+=j.getRunTime();					j.setEndTime(globaltime);					completedjobs.add(j);					j.getUser().consumed(j.getRunTime());					j.getUser().setLatest(globaltime);					jobs2completed.insert(j.projectName(),j);					jobs3completed.insert(j.userName(),j);					break;				}				waitjobs.search(p.projectName()).getValue().insert(j);				//unfinishedjobs.insert(j);				//System.out.println("\tUn-sufficient budget.");			}			//System.out.println("System execution completed");		}	}}